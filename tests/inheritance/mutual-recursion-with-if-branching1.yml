title: Mutual recursion in if branching
description: >
  Simplest branching case, where mutual recursion is obvious (if true/false)
features:
  - inheritance
  - overriding
  - method
  - polymorphism
language: cpp
bad:
  source.cpp: |
    #include <memory>

    class Base {
    private:
        int x = 0;
    public:
        Base() = default;
        virtual ~Base() = default;

        virtual void n() {
            this->x = 0;
        }
        void m() {
            this->n();
        }
        void incrX() {
            x++;
        }
    };

    class Derived : public Base {
    public:
        void n() override {
            if (true) {
                this->m();
            }
            else {
                this->incrX();
            }
        }
    };

    auto main() -> int {
        std::unique_ptr<Base> derivedInstance = std::make_unique<Derived>();
        derivedInstance->n();
    }
  test.eo: |
    [] > test
      [] > derived
        test.base > @
        test.base.x > x
        [self] > n
          if. > @
            TRUE
            self.m self
            x.write (x.add 1)

      [] > base
        memory > x
        [self] > n
          x.write 0 > @
        [self] > m
          self.n self > @
good:
  source.cpp: |
    #include <memory>

    class Base {
    private:
        int x = 0;
    public:
        Base() = default;
        virtual ~Base() = default;

        virtual void n() {
            this->x = 0;
        }
        void m() {
            this->n();
        }
        void incrX() {
            x++;
        }
    };

    class Derived : public Base {
    public:
        void n() override {
            if (false) {
                this->m();
            }
            else {
                this->incrX();
            }
        }
    };

    auto main() -> int {
        std::unique_ptr<Base> derivedInstance = std::make_unique<Derived>();
        derivedInstance->n();
    }
  test.eo: |
    [] > test
      [] > derived
        test.base > @
        test.base.x > x
        [self] > n
          if. > @
            FALSE
            self.m self
            x.write (x.add 1)

      [] > base
        memory > x
        [self] > n
          x.write 0 > @
        [self] > m
          self.n self > @
