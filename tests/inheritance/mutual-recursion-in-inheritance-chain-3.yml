title: Mutual recursion in a chain of inheritance
description: >
  Mutual recursion occurs in the inheritance chain when adding
  a new method m in the first derived class and overriding method n
  in the last class of the inheritance chain
features:
  - inheritance
  - overriding
  - method
  - polymorphism
language: cpp
bad:
  source.cpp: |
    class Base {
    public:
        int x;

        Base() {
            this->x = 0;
        }
        virtual ~Base() {}

        virtual void n(int v) {
            this->x = v;
        }
    };

    class Derived : public Base {
    public:
        void m(int v) {
            this->n(v);
        }
    };

    class DerivedAgain : public Derived {
    public:
        virtual void n(int v) override {
            this->m(v);
        }
    };

    int main() {
        Base *derivedAgainInstance = new DerivedAgain();
        derivedAgainInstance->n(12);
        delete derivedAgainInstance;
    }
  test.eo: |
    [] > test
      [] > base
        memory > x
        [self v] > n
          x.write v > @

      [] > derived
        test.base > @
        [self v] > m
          self.n self v > @

      [] > derived_again
        test.derived > @
        [self v] > n
          self.m self v > @
good:
  source.cpp: |
    class Base {
    public:
        int x;

        Base() {
            this->x = 0;
        }
        virtual ~Base() {}

        void n(int v) {
            this->x = v;
        }
    };

    class Derived : public Base {
    public:
        void m(int v) {
            this->n(v);
        }
    };

    class DerivedAgain : public Derived {
    public:
        virtual void n(int v) {
            this->m(v);
        }
    };

    int main() {
        Base *derivedAgainInstance = new DerivedAgain();
        derivedAgainInstance->n(12);
        delete derivedAgainInstance;
    }
  test.eo: |
    [] > test
      [] > base
        memory > x
        [self v] > n
          x.write v > @

      [] > derived
        test.base > @
        [self v] > m
          self.n self v > @

      [] > derived_again
        test.derived > @
        [self v] > n1
          self.m self v > @
